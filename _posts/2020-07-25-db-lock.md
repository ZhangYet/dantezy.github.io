---
title: "关于 CRUD 工程师日常遇到 mysql 锁问题的那些事"
tags: ["programming"]
date: 2020-07-25 16:08:24
layout: post
excerpt: 当然这个本来想 neta 《关公说事》，但后来我发现 neta 《关于我转生成为史莱姆这件事》会更合适。本文其实是要探究在给定索引情况更新表的时候，innodb 会加什么锁。
categories: programming
comments: true
---

## 背景 ##

现在在做促销的工作，上周某个需求需要我记录某个商家享受某个活动的折扣。我用一张表记录这个店家享受了折扣的次数：

```sql
CREATE TABLE `issued_history_tab` (
  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,
  `create_time` int(10) unsigned NOT NULL DEFAULT '0',
  `update_time` int(10) unsigned NOT NULL DEFAULT '0',
  `event_id` bigint(64) NOT NULL DEFAULT '0',
  `dimension_key` varchar(128) NOT NULL DEFAULT '',
  `dimension_value` varchar(128) NOT NULL DEFAULT '',
  `dimension_count` int(10) unsigned NOT NULL DEFAULT '0',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE KEY `uniq_dimension_idx` (`event_id`,`dimension_value`,`dimension_key`),
  KEY `idx_event_id` (`event_id`),
  KEY `idx_dimension_pair` (`dimension_value`,`dimension_key`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

这里会有一个问题，正常情况下，我们只需要 update `dimension_count` 即可如果一个商家从来没有享受过活动优惠，那它不会在表里面有记录。对于这种商家，我们要先插入一条记录，再 update 都应的 `dimension_count` 的数量。在并发的情况下，就要考虑锁的问题。

我们最初考虑采用 `ON DUPLICATE KEY UPDATE` 这种方案，然后怀疑会有死锁的风险。当时做了几个测试，但是都不能确定会不会死锁，于是我们放弃了这种方案。现在有闲暇了，我决定研究一下，究竟会不会死锁，或者简单来说，本文其实是要探究在给定索引情况更新表的时候，innodb 会加什么锁[^1]。

## 测试 ##

首先，我们需要打开监控[^2]。



```
------------
TRANSACTIONS
------------
Trx id counter 30360
Purge done for trx's n:o < 30358 undo n:o < 0 state: running but idle
History list length 35
LIST OF TRANSACTIONS FOR EACH SESSION:
---TRANSACTION 421953960198600, not started
0 lock struct(s), heap size 1136, 0 row lock(s)
---TRANSACTION 421953960196792, not started
0 lock struct(s), heap size 1136, 0 row lock(s)
---TRANSACTION 30359, ACTIVE 6 sec inserting
mysql tables in use 1, locked 1
LOCK WAIT 2 lock struct(s), heap size 1136, 1 row lock(s), undo log entries 1
MySQL thread id 21, OS thread handle 123145566531584, query id 4060 localhost 127.0.0.1 promodev update
INSERT INTO `issued_history_tab` (`event_id`, `dimension_key`, `dimension_value`, `dimension_count`) VALUE (10088, "merchant_id", "0080", 1) ON DUPLICATE KEY UPDATE `dimension_count` = `dimension_count` + 1
------- TRX HAS BEEN WAITING 6 SEC FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 694 page no 4 n bits 72 index uniq_dimension_idx of table `beepay_txn_db`.`issued_history_tab` trx id 30359 lock_mode X waiting
Record lock, heap no 4 PHYSICAL RECORD: n_fields 4; compact format; info bits 0
 0: len 8; hex 8000000000002768; asc       'h;;
 1: len 4; hex 30303830; asc 0080;;
 2: len 11; hex 6d65726368616e745f6964; asc merchant_id;;
 3: len 8; hex 0000000000000004; asc         ;;

------------------
TABLE LOCK table `beepay_txn_db`.`issued_history_tab` trx id 30359 lock mode IX
RECORD LOCKS space id 694 page no 4 n bits 72 index uniq_dimension_idx of table `beepay_txn_db`.`issued_history_tab` trx id 30359 lock_mode X waiting
Record lock, heap no 4 PHYSICAL RECORD: n_fields 4; compact format; info bits 0
 0: len 8; hex 8000000000002768; asc       'h;;
 1: len 4; hex 30303830; asc 0080;;
 2: len 11; hex 6d65726368616e745f6964; asc merchant_id;;
 3: len 8; hex 0000000000000004; asc         ;;

---TRANSACTION 30358, ACTIVE 10 sec inserting
mysql tables in use 1, locked 1
LOCK WAIT 2 lock struct(s), heap size 1136, 1 row lock(s), undo log entries 1
MySQL thread id 18, OS thread handle 123145565417472, query id 4057 localhost 127.0.0.1 promodev update
INSERT INTO `issued_history_tab` (`event_id`, `dimension_key`, `dimension_value`, `dimension_count`) VALUE (10088, "merchant_id", "0080", 1) ON DUPLICATE KEY UPDATE `dimension_count` = `dimension_count` + 1
------- TRX HAS BEEN WAITING 10 SEC FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 694 page no 4 n bits 72 index uniq_dimension_idx of table `beepay_txn_db`.`issued_history_tab` trx id 30358 lock_mode X waiting
Record lock, heap no 4 PHYSICAL RECORD: n_fields 4; compact format; info bits 0
 0: len 8; hex 8000000000002768; asc       'h;;
 1: len 4; hex 30303830; asc 0080;;
 2: len 11; hex 6d65726368616e745f6964; asc merchant_id;;
 3: len 8; hex 0000000000000004; asc         ;;

------------------
TABLE LOCK table `beepay_txn_db`.`issued_history_tab` trx id 30358 lock mode IX
RECORD LOCKS space id 694 page no 4 n bits 72 index uniq_dimension_idx of table `beepay_txn_db`.`issued_history_tab` trx id 30358 lock_mode X waiting
Record lock, heap no 4 PHYSICAL RECORD: n_fields 4; compact format; info bits 0
 0: len 8; hex 8000000000002768; asc       'h;;
 1: len 4; hex 30303830; asc 0080;;
 2: len 11; hex 6d65726368616e745f6964; asc merchant_id;;
 3: len 8; hex 0000000000000004; asc         ;;

---TRANSACTION 30353, ACTIVE 17 sec
2 lock struct(s), heap size 1136, 1 row lock(s), undo log entries 1
MySQL thread id 16, OS thread handle 123145565696000, query id 4054 localhost 127.0.0.1 promodev
TABLE LOCK table `beepay_txn_db`.`issued_history_tab` trx id 30353 lock mode IX
RECORD LOCKS space id 694 page no 4 n bits 72 index uniq_dimension_idx of table `beepay_txn_db`.`issued_history_tab` trx id 30353 lock_mode X locks rec but not gap
Record lock, heap no 4 PHYSICAL RECORD: n_fields 4; compact format; info bits 0
 0: len 8; hex 8000000000002768; asc       'h;;
 1: len 4; hex 30303830; asc 0080;;
 2: len 11; hex 6d65726368616e745f6964; asc merchant_id;;
 3: len 8; hex 0000000000000004; asc         ;;
```

## 脚注 ##

[^1]: 其实我很好奇，到底哪里还有不用 innodb 的场景。

[^2]: 参考文献：[MySQL加锁分析](http://www.fanyilun.me/2017/04/20/MySQL%E5%8A%A0%E9%94%81%E5%88%86%E6%9E%90/)
