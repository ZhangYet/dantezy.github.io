<p><code class="highlighter-rouge">go</code> 1.11 引入了 <a href="https://github.com/golang/go/wiki/Modules">modules</a> 这个特性。本文是该文档的摘要笔记。</p>

<h2 id="quickstart">Quickstart</h2>

<p>官方的 <a href="https://github.com/golang/go/wiki/Modules#example">quickstart</a> 给了一个例子，但是我在编译的时候遇到了错误：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>go: golang.org/x/text@v0.0.0-20170915032832-14c0d48ead0c: unrecognized import path <span class="s2">"golang.org/x/text"</span> <span class="o">(</span>https fetch: Get https://golang.org/x/text?go-get<span class="o">=</span>1: dial tcp 216.239.37.1:443: i/o <span class="nb">timeout</span><span class="o">)</span>
go: error loading module requirements
</code></pre></div></div>

<p>云栖社区给了一个<a href="https://yq.aliyun.com/articles/663151">解决方案</a>，但是我发现还是不行，最终的解决方案如下：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>go mod edit <span class="nt">-replace</span><span class="o">=</span>golang.org/x/text@v0.0.0-20170915032832-14c0d48ead0c<span class="o">=</span>github.com/golang/text@latest
</code></pre></div></div>

<p>这是因为 text 没有语义性版本，所以它的版本号是 <a href="https://tip.golang.org/cmd/go/#hdr-Pseudo_versions">pseudo-versions</a>。</p>

<h2 id="概念">概念</h2>

<ol>
  <li><code class="highlighter-rouge">modules</code>: 不同的 package 组成的一个 versioned unit，简单来说就是一组 package， 但是作为整体带上了 version。 每个 module 都带有<a href="https://semver.org/">语义性版本号</a>。</li>
  <li><code class="highlighter-rouge">go.mod</code>: 一个定义了整个 module 的文本文件，有四指令：<code class="highlighter-rouge">module</code>, <code class="highlighter-rouge">require</code>, <code class="highlighter-rouge">replace</code>, <code class="highlighter-rouge">exclude</code>。关于 <code class="highlighter-rouge">module</code>，文档说得很清楚，我不想概括复述了。</li>
</ol>

<blockquote>
  <p>A module declares its identity in its go.mod via the module directive, which provides the module path. The import paths for all packages in a module share the module path as a common prefix. The module path and the relative path from the go.mod to a package’s directory together determine a package’s import path.</p>
</blockquote>

<ol>
  <li><code class="highlighter-rouge">version selection</code>: 如果你通过 <code class="highlighter-rouge">go.mod</code> 里面的 <code class="highlighter-rouge">require</code> 引入了外部的 module，在 <code class="highlighter-rouge">go build</code> 的时候，<code class="highlighter-rouge">go.mod</code> 会自动选择最高的版本。假如你引入了某个 module A 要求它的版本是 v1.0.0。后来你再引入龄一个 module B，B 依赖于 v1.2.0 的 A，那么会根据最小版本原则，选择 v1.0.0。<strong>这里我想吐槽一句，假如依赖的版本不兼容又不遵守 semver 的规范呢（比如上例中 A 的 v1.0.0 和 v1.2.0 有不兼容的版本，而我们又必须同时依赖 A 和 B 呢）？</strong></li>
  <li><code class="highlighter-rouge">semantic import versioning</code>: 就是说，module 必须遵循 <a href="https://semver.org/">semver</a>, v2 必须在 <code class="highlighter-rouge">go.mod</code> 的 <code class="highlighter-rouge">module</code> 中说明。</li>
</ol>

<h2 id="如何使用-module">如何使用 module</h2>

<h3 id="定义-module">定义 module</h3>

<ol>
  <li>如果项目目录在 <code class="highlighter-rouge">GOPATH</code> 之外，那么不需要特别操作，如果在 <code class="highlighter-rouge">GOPATH</code> 内，需要 <code class="highlighter-rouge">export GO111MODULE=on</code>。如果不加，会提示 <code class="highlighter-rouge">go: modules disabled inside GOPATH/src by GO111MODULE=auto; see 'go help modules'</code>。</li>
  <li>创建 module 定义，<code class="highlighter-rouge">go mod init</code>，这一步会把现有的依赖文件（<a href="https://tip.golang.org/pkg/cmd/go/internal/modconv/?m=all#pkg-variables">支持的格式</a>）中的依赖项加到 <code class="highlighter-rouge">go.mod</code> 文件里面。<code class="highlighter-rouge">init</code> 命令可以根据 VCS 的信息，确定 module 路径，也可以自定义 module 路径，比如：<code class="highlighter-rouge">go mod init github.com/my/repo</code>。</li>
  <li><code class="highlighter-rouge">go build ./... &amp;&amp; go test ./...</code></li>
</ol>

<h3 id="依赖升级和降级">依赖升级和降级</h3>

<p><code class="highlighter-rouge">go get</code> 会自动修改 <code class="highlighter-rouge">go.mod</code>。实际上，<code class="highlighter-rouge">go build</code>, <code class="highlighter-rouge">go test</code> 甚至 <code class="highlighter-rouge">go list</code> 都会自动增加新依赖。</p>

<p><code class="highlighter-rouge">go get</code> 的几种情况（注意这些命令不但会更新 foo，还会更新 foo 的依赖）：</p>

<ol>
  <li><code class="highlighter-rouge">go get -u foo</code> 使用最新的 minor 或 patch 版本；</li>
  <li><code class="highlighter-rouge">go get -u=patch foo</code> 使用最新的 patch 版本；</li>
  <li><code class="highlighter-rouge">go get foo</code> 使用最新版本；</li>
  <li><code class="highlighter-rouge">go get foo@e3702bed2</code> 和 <code class="highlighter-rouge">go get foo@'&lt;v1.6.2'</code> 使用指定版本；</li>
</ol>

<p>没有时候用语义版本的 module 会使用 <a href="https://tip.golang.org/cmd/go/#hdr-Pseudo_versions">pseudo-versions</a>。</p>

<h3 id="release-module">release module</h3>

<p>一般的发布就是</p>

<ol>
  <li><code class="highlighter-rouge">go mod tidy</code>，因为其他会改动 <code class="highlighter-rouge">go.mod</code> 的命令都不会删除不用的依赖;</li>
  <li><code class="highlighter-rouge">go test all</code>，;</li>
  <li>将 <code class="highlighter-rouge">go.sum</code> 加到库里;</li>
</ol>

<p>但是如果要发布的版本是 v2 以上，那就有点麻烦了。主要有一点：如果你的项目是从 v2.0.0 或以上的版本，开始用 module，那么最好把主版本号加1。原因是：</p>

<blockquote>
  <p>Incrementing the major version in this case provides greater clarity to consumers of foo, allows for additional non-module patches or minor releases on the v2 series of foo if needed, and provides a strong signal for a module-based consumer of foo that different major versions result if you do import “foo” and a corresponding require foo v2.2.2+incompatible, vs. import “foo/v3” and a corresponding require foo/v3 v3.0.0.</p>
</blockquote>

<p>有两种发布方式：主分支发布，或者增加一个版本子目录发布。module path 后面都要加上主版本号。</p>

<h3 id="publish-a-release">publish a release</h3>

<p>通过打 tag 来发布新版本，tag 应该是 prefix(module) + version。</p>

<h2 id="迁移到-module">迁移到 module</h2>

<p>如果是 v2 或以后的版本，迁移会需要做更多的考量。</p>

<p>值得注意的是，如果以前你的文档要求的安装指令是：<code class="highlighter-rouge">go get -u</code>，那你应该去掉 <code class="highlighter-rouge">-u</code>。</p>

<p>此外还有几个小问题：</p>

<ol>
  <li>module 引用非 module 依赖：直接用就行，如果依赖是 v2 以上的版本，<code class="highlighter-rouge">require</code> 会在版本号后面加上 <code class="highlighter-rouge">+incompatible</code>。</li>
  <li>非 module 引用 module：v2 以下版本没有问题，1.9.7+, 1.10.3+ and 1.11 可以使用 v2 的 module， 之前的版本会要求 module 通过子文件夹的方式发布。</li>
</ol>

